# 価格帯別商品数集計

## 📖 問題文（日本語訳）

ある衣類ショッピングモールで販売中の商品情報を管理する `PRODUCT` テーブルがあります。

このテーブルから、万円単位の価格帯別に商品の個数を集計して出力してください。

**条件**：
- カラム名：PRICE_GROUP（価格帯）、PRODUCTS（商品数）
- 価格帯情報は各区間の最小金額で表示（例：10000円以上～20000円未満 → 10000）
- 結果は価格帯を基準に昇順でソート

**価格帯の定義**：
- 0円～9999円 → 0
- 10000円～19999円 → 10000
- 20000円～29999円 → 20000
- 30000円～39999円 → 30000
- ...

## 📊 テーブル構造

### PRODUCT テーブル

| Column name  | Type        | Nullable | 説明                     |
|--------------|-------------|----------|--------------------------|
| PRODUCT_ID   | INTEGER     | FALSE    | 商品ID                   |
| PRODUCT_CODE | VARCHAR(8)  | FALSE    | 商品コード（8桁）        |
| PRICE        | INTEGER     | FALSE    | 販売価格                 |

**注意事項**：
- 商品コードは8桁で重複なし
- 先頭2桁はカテゴリコード

### サンプルデータ

| PRODUCT_ID | PRODUCT_CODE | PRICE  |
|------------|--------------|--------|
| 1          | A1000011     | 10000  |
| 2          | A1000045     | 9000   |
| 3          | C3000002     | 22000  |
| 4          | C3000006     | 15000  |
| 5          | C3000010     | 30000  |
| 6          | K1000023     | 17000  |

**価格帯分類**：
- 0円台（0～9999）: PRODUCT_ID=2（9000円）→ 1個
- 10000円台（10000～19999）: PRODUCT_ID=1,4,6（10000, 15000, 17000円）→ 3個
- 20000円台（20000～29999）: PRODUCT_ID=3（22000円）→ 1個
- 30000円台（30000～39999）: PRODUCT_ID=5（30000円）→ 1個

## 🎯 期待される出力

| PRICE_GROUP | PRODUCTS |
|-------------|----------|
| 0           | 1        |
| 10000       | 3        |
| 20000       | 1        |
| 30000       | 1        |

## 💡 解答

### 最適化されたSQL

```sql
SELECT
    FLOOR(PRICE / 10000) * 10000 AS PRICE_GROUP,
    COUNT(*) AS PRODUCTS
FROM PRODUCT
GROUP BY PRICE_GROUP
ORDER BY PRICE_GROUP;
```

### 代替解法（DIV演算子）

```sql
SELECT
    (PRICE DIV 10000) * 10000 AS PRICE_GROUP,
    COUNT(*) AS PRODUCTS
FROM PRODUCT
GROUP BY PRICE_GROUP
ORDER BY PRICE_GROUP;
```

## 📝 解説

### 解法のポイント

1. **価格帯の計算方法**
   ```
   FLOOR(PRICE / 10000) * 10000
   ```

   **計算例**：
   - 9000円: FLOOR(9000 / 10000) * 10000 = FLOOR(0.9) * 10000 = 0 * 10000 = 0
   - 15000円: FLOOR(15000 / 10000) * 10000 = FLOOR(1.5) * 10000 = 1 * 10000 = 10000
   - 22000円: FLOOR(22000 / 10000) * 10000 = FLOOR(2.2) * 10000 = 2 * 10000 = 20000
   - 30000円: FLOOR(30000 / 10000) * 10000 = FLOOR(3.0) * 10000 = 3 * 10000 = 30000

2. **FLOOR()関数の理解**
   - `FLOOR(n)`：nの小数点以下を切り捨てて整数化
   - 例：FLOOR(1.9) = 1、FLOOR(2.1) = 2
   - 負の数の場合は下方向（FLOOR(-1.5) = -2）

3. **GROUP BYでのエイリアス使用**
   ```sql
   SELECT
       FLOOR(PRICE / 10000) * 10000 AS PRICE_GROUP,
       COUNT(*) AS PRODUCTS
   FROM PRODUCT
   GROUP BY PRICE_GROUP  -- エイリアスを直接使用可能（MySQL）
   ```

   - MySQLではGROUP BYでSELECT句のエイリアスが使える
   - 他のDBMSでは式を繰り返す必要がある場合も

   **標準SQL対応版**：
   ```sql
   GROUP BY FLOOR(PRICE / 10000) * 10000
   ```

4. **COUNT(*)による集計**
   - 各価格帯グループの行数をカウント
   - NULL値も含めてカウント（PRICEはNOT NULL）

### パフォーマンスチューニング

#### インデックス戦略

**推奨インデックス**：
```sql
CREATE INDEX idx_product_price ON PRODUCT(PRICE);
```

**理由**：
- GROUP BY操作でPRICE列を使用
- インデックスによりソート済みデータを効率的に読める
- ORDER BYでも同じ順序なのでソート操作を削減

**効果**：
- フルテーブルスキャンを回避
- グループ化とソートを効率化

#### 生成列による高度な最適化

大量データの場合、計算式を生成列として事前計算：

```sql
-- 生成列を追加
ALTER TABLE PRODUCT
ADD COLUMN price_group INTEGER
GENERATED ALWAYS AS (FLOOR(PRICE / 10000) * 10000) STORED;

-- 生成列にインデックスを作成
CREATE INDEX idx_product_price_group ON PRODUCT(price_group);

-- クエリを簡素化
SELECT
    price_group AS PRICE_GROUP,
    COUNT(*) AS PRODUCTS
FROM PRODUCT
GROUP BY price_group
ORDER BY price_group;
```

**メリット**：
- 計算式が毎回実行されない（事前計算済み）
- インデックスが直接効く（計算列にインデックス）
- GROUP BYとORDER BYが高速化

**デメリット**：
- ストレージ容量が増加
- INSERT/UPDATE時に計算コスト
- 小規模データでは不要（オーバーヘッド）

#### 実行計画の確認

```sql
EXPLAIN SELECT
    FLOOR(PRICE / 10000) * 10000 AS PRICE_GROUP,
    COUNT(*) AS PRODUCTS
FROM PRODUCT
GROUP BY PRICE_GROUP
ORDER BY PRICE_GROUP;
```

**チェックポイント**：
- `type`: `index` または `ALL`
- `key`: `idx_product_price` インデックスが使用されることを確認
- `Extra`: `Using index` が理想（カバリングインデックス）
- `Extra`: `Using temporary; Using filesort` は改善余地あり

### 代替アプローチ

#### オプション1：DIV演算子（整数除算）

```sql
SELECT
    (PRICE DIV 10000) * 10000 AS PRICE_GROUP,
    COUNT(*) AS PRODUCTS
FROM PRODUCT
GROUP BY PRICE_GROUP
ORDER BY PRICE_GROUP;
```

**評価**：
- `DIV`：整数除算（小数点以下切り捨て）
- FLOOR()と同じ結果（正の数の場合）
- よりシンプルで可読性が高い
- パフォーマンスは同等
- **推奨**：可読性を重視する場合

#### オプション2：TRUNCATE関数

```sql
SELECT
    TRUNCATE(PRICE / 10000, 0) * 10000 AS PRICE_GROUP,
    COUNT(*) AS PRODUCTS
FROM PRODUCT
GROUP BY PRICE_GROUP
ORDER BY PRICE_GROUP;
```

**評価**：
- `TRUNCATE(n, d)`：nをd桁で切り捨て
- TRUNCATE(1.567, 0) = 1
- FLOOR()と同じ結果（正の数の場合）
- パフォーマンスは同等

#### オプション3：CASE式による明示的グループ化

```sql
SELECT
    CASE
        WHEN PRICE < 10000 THEN 0
        WHEN PRICE < 20000 THEN 10000
        WHEN PRICE < 30000 THEN 20000
        WHEN PRICE < 40000 THEN 30000
        WHEN PRICE < 50000 THEN 40000
        ELSE FLOOR(PRICE / 10000) * 10000
    END AS PRICE_GROUP,
    COUNT(*) AS PRODUCTS
FROM PRODUCT
GROUP BY PRICE_GROUP
ORDER BY PRICE_GROUP;
```

**評価**：
- 明示的で理解しやすい
- 特定の価格帯のみ対象の場合に有用
- すべての価格帯を網羅する必要がある場合は冗長
- パフォーマンスは計算式より若干劣る
- 推奨しない（汎用性が低い）

### 関数の比較

| 関数/演算子 | 構文 | 9000の結果 | 15000の結果 | 負の数 |
|------------|------|-----------|------------|--------|
| FLOOR() | FLOOR(PRICE / 10000) * 10000 | 0 | 10000 | 下方向 |
| DIV | (PRICE DIV 10000) * 10000 | 0 | 10000 | 切り捨て |
| TRUNCATE() | TRUNCATE(PRICE / 10000, 0) * 10000 | 0 | 10000 | ゼロ方向 |

**推奨**：正の数（価格）の場合、すべて同じ結果。可読性を考慮してDIVまたはFLOOR()

## 🔑 キーワード

- `FLOOR()`：小数点以下切り捨て関数
- `DIV`：整数除算演算子
- `GROUP BY`：グループ化と集計
- `COUNT(*)`：行数のカウント
- **価格帯グループ化**：万円単位での集計パターン
- **計算式のグループ化**：GROUP BYでの式の使用
- **生成列（Generated Column）**：計算結果の事前保存
- **エイリアスの活用**：GROUP BYでのエイリアス使用

## 🎓 学習ポイント

1. FLOOR()関数で小数点以下を切り捨てて整数化
2. GROUP BYで計算式を使って動的にグループ化できる
3. MySQLではGROUP BYでSELECT句のエイリアスが使える
4. DIV演算子は整数除算で可読性が高い
5. 生成列を使うと計算式に直接インデックスを作成できる
6. 価格帯グループ化は実務でよく使うパターン
7. インデックスでGROUP BYとORDER BY両方を最適化

## 💡 応用例

### カテゴリ別×価格帯別の集計

```sql
SELECT
    LEFT(PRODUCT_CODE, 2) AS CATEGORY,
    FLOOR(PRICE / 10000) * 10000 AS PRICE_GROUP,
    COUNT(*) AS PRODUCTS,
    AVG(PRICE) AS AVG_PRICE
FROM PRODUCT
GROUP BY CATEGORY, PRICE_GROUP
ORDER BY CATEGORY, PRICE_GROUP;
```

### 価格帯別の詳細統計

```sql
SELECT
    FLOOR(PRICE / 10000) * 10000 AS PRICE_GROUP,
    COUNT(*) AS PRODUCTS,
    MIN(PRICE) AS MIN_PRICE,
    MAX(PRICE) AS MAX_PRICE,
    AVG(PRICE) AS AVG_PRICE,
    SUM(PRICE) AS TOTAL_PRICE
FROM PRODUCT
GROUP BY PRICE_GROUP
ORDER BY PRICE_GROUP;
```

### 特定価格帯のみ抽出

```sql
SELECT
    FLOOR(PRICE / 10000) * 10000 AS PRICE_GROUP,
    COUNT(*) AS PRODUCTS
FROM PRODUCT
WHERE PRICE >= 10000 AND PRICE < 30000
GROUP BY PRICE_GROUP
ORDER BY PRICE_GROUP;
```

### 5万円単位でグループ化

```sql
SELECT
    FLOOR(PRICE / 50000) * 50000 AS PRICE_GROUP,
    COUNT(*) AS PRODUCTS
FROM PRODUCT
GROUP BY PRICE_GROUP
ORDER BY PRICE_GROUP;
```

### 価格帯別構成比の計算

```sql
SELECT
    FLOOR(PRICE / 10000) * 10000 AS PRICE_GROUP,
    COUNT(*) AS PRODUCTS,
    ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM PRODUCT), 2) AS PERCENTAGE
FROM PRODUCT
GROUP BY PRICE_GROUP
ORDER BY PRICE_GROUP;
```

---

**作成日**: 2025-10-08
**難易度**: ⭐⭐ 基本～中級
**カテゴリ**: GROUP BY, FLOOR, 集計関数, 計算式グループ化, インデックス最適化
