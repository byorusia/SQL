# レンタル期間分類検索

## 📖 問題文（日本語訳）

ある自動車レンタル会社の自動車レンタル記録情報を管理する `CAR_RENTAL_COMPANY_RENTAL_HISTORY` テーブルがあります。

このテーブルから、2022年9月に開始したレンタル記録について、以下の条件で分類したカラム（RENT_TYPE）を追加して出力してください：

- レンタル期間が30日以上：「長期レンタル」
- レンタル期間が30日未満：「短期レンタル」
- 結果はレンタル記録IDを基準に降順でソート

## 📊 テーブル構造

### CAR_RENTAL_COMPANY_RENTAL_HISTORY テーブル

| Column name | Type    | Nullable | 説明                     |
|-------------|---------|----------|--------------------------|
| HISTORY_ID  | INTEGER | FALSE    | 自動車レンタル記録ID     |
| CAR_ID      | INTEGER | FALSE    | 自動車ID                 |
| START_DATE  | DATE    | FALSE    | レンタル開始日           |
| END_DATE    | DATE    | FALSE    | レンタル終了日           |

### サンプルデータ

| HISTORY_ID | CAR_ID | START_DATE | END_DATE   |
|------------|--------|------------|------------|
| 1          | 4      | 2022-09-27 | 2022-11-27 |
| 2          | 3      | 2022-10-03 | 2022-11-04 |
| 3          | 2      | 2022-09-05 | 2022-09-05 |
| 4          | 1      | 2022-09-01 | 2022-09-30 |
| 5          | 3      | 2022-09-16 | 2022-10-15 |

**期間計算の例**：
- HISTORY_ID=1: 2022-09-27 ～ 2022-11-27 = 62日間 → 長期レンタル
- HISTORY_ID=4: 2022-09-01 ～ 2022-09-30 = 30日間 → 長期レンタル
- HISTORY_ID=3: 2022-09-05 ～ 2022-09-05 = 1日間 → 短期レンタル
- HISTORY_ID=5: 2022-09-16 ～ 2022-10-15 = 30日間 → 短期レンタル（境界値）

## 🎯 期待される出力

| HISTORY_ID | CAR_ID | START_DATE | END_DATE   | RENT_TYPE      |
|------------|--------|------------|------------|----------------|
| 5          | 3      | 2022-09-16 | 2022-10-15 | 短期レンタル   |
| 4          | 1      | 2022-09-01 | 2022-09-30 | 長期レンタル   |
| 3          | 2      | 2022-09-05 | 2022-09-05 | 短期レンタル   |
| 1          | 4      | 2022-09-27 | 2022-11-27 | 長期レンタル   |

**注意事項**：
- START_DATE と END_DATE は `'%Y-%m-%d'` フォーマットで出力
- HISTORY_ID 降順でソート
- 2022年9月開始の記録のみ抽出（HISTORY_ID=2は10月開始なので除外）

## 💡 解答

### 最適化されたSQL

```sql
SELECT
    HISTORY_ID,
    CAR_ID,
    DATE_FORMAT(START_DATE, '%Y-%m-%d') AS START_DATE,
    DATE_FORMAT(END_DATE, '%Y-%m-%d') AS END_DATE,
    CASE
        WHEN DATEDIFF(END_DATE, START_DATE) >= 29 THEN '長期レンタル'
        ELSE '短期レンタル'
    END AS RENT_TYPE
FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
WHERE START_DATE >= '2022-09-01' AND START_DATE < '2022-10-01'
ORDER BY HISTORY_ID DESC;
```

## 📝 解説

### 解法のポイント

1. **期間計算の理解**
   - `DATEDIFF(END_DATE, START_DATE)`：終了日と開始日の日数差を計算
   - 実際の日数 = DATEDIFF + 1日（開始日を含むため）
   - 30日以上 = DATEDIFF >= 29（開始日含めて30日）

   **例**：
   - 9/1 ～ 9/30: DATEDIFF = 29、実日数 = 30日 → 長期
   - 9/5 ～ 9/5: DATEDIFF = 0、実日数 = 1日 → 短期

2. **CASE式による条件分岐**
   ```sql
   CASE
       WHEN DATEDIFF(END_DATE, START_DATE) >= 29 THEN '長期レンタル'
       ELSE '短期レンタル'
   END AS RENT_TYPE
   ```
   - 条件に応じて異なる値を返す
   - 新しいカラムとして追加

3. **WHERE句の範囲検索**
   - `START_DATE >= '2022-09-01' AND START_DATE < '2022-10-01'`
   - 関数を使わずインデックスを活用
   - 2022年9月1日～9月30日のレコードを抽出

4. **日付フォーマット**
   - `DATE_FORMAT(date_column, '%Y-%m-%d')`
   - SELECT句で変換（WHERE句のパフォーマンスに影響なし）

### パフォーマンスチューニング

#### インデックス戦略

**推奨インデックス**：
```sql
CREATE INDEX idx_rental_start_date ON CAR_RENTAL_COMPANY_RENTAL_HISTORY(START_DATE);
```

**理由**：
- WHERE句の範囲検索に最適化
- 関数を使わない条件なのでインデックスが効く
- 大量データでフルテーブルスキャンを回避

#### 複合インデックスの検討

```sql
CREATE INDEX idx_rental_start_history
ON CAR_RENTAL_COMPANY_RENTAL_HISTORY(START_DATE, HISTORY_ID);
```

**効果**：
- WHERE句とORDER BY両方をカバー
- カバリングインデックスとして機能
- ソート操作を削減

#### クエリ実行計画の確認

```sql
EXPLAIN SELECT
    HISTORY_ID,
    CAR_ID,
    DATE_FORMAT(START_DATE, '%Y-%m-%d') AS START_DATE,
    DATE_FORMAT(END_DATE, '%Y-%m-%d') AS END_DATE,
    CASE
        WHEN DATEDIFF(END_DATE, START_DATE) >= 29 THEN '長期レンタル'
        ELSE '短期レンタル'
    END AS RENT_TYPE
FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
WHERE START_DATE >= '2022-09-01' AND START_DATE < '2022-10-01'
ORDER BY HISTORY_ID DESC;
```

**チェックポイント**：
- `type`: `range`（範囲検索）が表示されることを確認
- `key`: `idx_rental_start_date` インデックスが使用されることを確認
- `Extra`: `Using filesort` が表示される場合、複合インデックスを検討

### 代替アプローチ

#### オプション1：YEAR/MONTH関数を使用（非推奨）

```sql
SELECT
    HISTORY_ID,
    CAR_ID,
    DATE_FORMAT(START_DATE, '%Y-%m-%d') AS START_DATE,
    DATE_FORMAT(END_DATE, '%Y-%m-%d') AS END_DATE,
    CASE
        WHEN DATEDIFF(END_DATE, START_DATE) >= 29 THEN '長期レンタル'
        ELSE '短期レンタル'
    END AS RENT_TYPE
FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
WHERE YEAR(START_DATE) = 2022 AND MONTH(START_DATE) = 9
ORDER BY HISTORY_ID DESC;
```

**評価**：
- 関数を使うためインデックスが効かない
- フルテーブルスキャンの可能性
- 推奨しない

#### オプション2：期間を明示的に計算

```sql
SELECT
    HISTORY_ID,
    CAR_ID,
    DATE_FORMAT(START_DATE, '%Y-%m-%d') AS START_DATE,
    DATE_FORMAT(END_DATE, '%Y-%m-%d') AS END_DATE,
    CASE
        WHEN DATEDIFF(END_DATE, START_DATE) + 1 >= 30 THEN '長期レンタル'
        ELSE '短期レンタル'
    END AS RENT_TYPE
FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
WHERE START_DATE >= '2022-09-01' AND START_DATE < '2022-10-01'
ORDER BY HISTORY_ID DESC;
```

**評価**：
- `DATEDIFF + 1` で実日数を明示的に計算
- より分かりやすい条件式
- パフォーマンスは同等
- 可読性を重視する場合に推奨

#### オプション3：サブクエリで期間を事前計算

```sql
SELECT
    HISTORY_ID,
    CAR_ID,
    DATE_FORMAT(START_DATE, '%Y-%m-%d') AS START_DATE,
    DATE_FORMAT(END_DATE, '%Y-%m-%d') AS END_DATE,
    CASE
        WHEN rental_days >= 30 THEN '長期レンタル'
        ELSE '短期レンタル'
    END AS RENT_TYPE
FROM (
    SELECT
        *,
        DATEDIFF(END_DATE, START_DATE) + 1 AS rental_days
    FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
    WHERE START_DATE >= '2022-09-01' AND START_DATE < '2022-10-01'
) AS rental_with_days
ORDER BY HISTORY_ID DESC;
```

**評価**：
- 期間計算を一度だけ実行
- 複雑なCASE条件の場合に有用
- このシンプルなケースでは不要（オーバーエンジニアリング）

### DATEDIFF関数の理解

**構文**：
```sql
DATEDIFF(date1, date2)
```

**戻り値**：date1 - date2 の日数（整数）

**例**：
| 開始日     | 終了日     | DATEDIFF | 実日数（開始日含む） |
|-----------|-----------|----------|---------------------|
| 2022-09-01 | 2022-09-01 | 0        | 1日                 |
| 2022-09-01 | 2022-09-02 | 1        | 2日                 |
| 2022-09-01 | 2022-09-30 | 29       | 30日                |
| 2022-09-01 | 2022-10-01 | 30       | 31日                |

**重要**：実際のレンタル日数 = DATEDIFF + 1

## 🔑 キーワード

- `CASE`：条件分岐式
- `DATEDIFF()`：日付の差分を計算する関数
- `DATE_FORMAT()`：日付フォーマット変換
- **範囲検索**：関数を避けてインデックスを活用
- **期間計算**：DATEDIFF + 1 = 実日数
- **条件分岐**：CASE WHEN THEN ELSE END
- **降順ソート**：ORDER BY DESC

## 🎓 学習ポイント

1. CASE式で条件に応じた値を動的に生成できる
2. DATEDIFF()は日数差を返す（開始日は含まない）
3. 実日数 = DATEDIFF + 1（開始日を含める）
4. WHERE句で関数を使わず範囲検索でインデックスを活用
5. 複数の日付カラムを同時にフォーマット変換できる
6. ORDER BY DESC で降順ソート
7. 複合インデックスでWHERE句とORDER BY両方を最適化

## 💡 応用例

### 期間別の集計

```sql
SELECT
    CASE
        WHEN DATEDIFF(END_DATE, START_DATE) >= 29 THEN '長期レンタル'
        ELSE '短期レンタル'
    END AS RENT_TYPE,
    COUNT(*) AS rental_count,
    AVG(DATEDIFF(END_DATE, START_DATE) + 1) AS avg_days
FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
WHERE START_DATE >= '2022-09-01' AND START_DATE < '2022-10-01'
GROUP BY RENT_TYPE;
```

### 複数の期間分類

```sql
SELECT
    HISTORY_ID,
    CAR_ID,
    DATEDIFF(END_DATE, START_DATE) + 1 AS rental_days,
    CASE
        WHEN DATEDIFF(END_DATE, START_DATE) + 1 >= 90 THEN '超長期'
        WHEN DATEDIFF(END_DATE, START_DATE) + 1 >= 30 THEN '長期'
        WHEN DATEDIFF(END_DATE, START_DATE) + 1 >= 7 THEN '中期'
        ELSE '短期'
    END AS RENT_TYPE
FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
WHERE START_DATE >= '2022-09-01' AND START_DATE < '2022-10-01'
ORDER BY rental_days DESC;
```

### 月別期間分類集計

```sql
SELECT
    DATE_FORMAT(START_DATE, '%Y-%m') AS rental_month,
    CASE
        WHEN DATEDIFF(END_DATE, START_DATE) >= 29 THEN '長期レンタル'
        ELSE '短期レンタル'
    END AS RENT_TYPE,
    COUNT(*) AS count
FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
GROUP BY rental_month, RENT_TYPE
ORDER BY rental_month DESC, RENT_TYPE;
```

---

**作成日**: 2025-10-08
**難易度**: ⭐⭐ 基本～中級
**カテゴリ**: CASE, DATEDIFF, 日付計算, 条件分岐, インデックス最適化
