# 最高評価社員検索

## 📖 問題文（日本語訳）

会社の部署情報、社員情報、評価情報を管理する3つのテーブルがあります。

2022年度の年間評価点数（上半期+下半期の合計）が最も高い社員の情報を検索してください。

**条件**：
- 出力カラム：SCORE（年間合計点）、EMP_NO（社員番号）、EMP_NAME（氏名）、POSITION（役職）、EMAIL（メール）
- 2022年度の評価点数は上半期と下半期の点数の合計
- 最高点の社員のみ出力

## 📊 テーブル構造

### HR_DEPARTMENT テーブル（部署情報）

| Column name   | Type    | Nullable | 説明           |
|---------------|---------|----------|----------------|
| DEPT_ID       | VARCHAR | FALSE    | 部署ID         |
| DEPT_NAME_KR  | VARCHAR | FALSE    | 韓国語部署名   |
| DEPT_NAME_EN  | VARCHAR | FALSE    | 英語部署名     |
| LOCATION      | VARCHAR | FALSE    | 部署所在地     |

### HR_EMPLOYEES テーブル（社員情報）

| Column name | Type    | Nullable | 説明           |
|-------------|---------|----------|----------------|
| EMP_NO      | VARCHAR | FALSE    | 社員番号       |
| EMP_NAME    | VARCHAR | FALSE    | 氏名           |
| DEPT_ID     | VARCHAR | FALSE    | 部署ID         |
| POSITION    | VARCHAR | FALSE    | 役職           |
| EMAIL       | VARCHAR | FALSE    | メール         |
| COMP_TEL    | VARCHAR | FALSE    | 電話番号       |
| HIRE_DATE   | DATE    | FALSE    | 入社日         |
| SAL         | NUMBER  | FALSE    | 年俸           |

### HR_GRADE テーブル（2022年評価情報）

| Column name | Type   | Nullable | 説明           |
|-------------|--------|----------|----------------|
| EMP_NO      | VARCHAR| FALSE    | 社員番号       |
| YEAR        | NUMBER | FALSE    | 年度           |
| HALF_YEAR   | NUMBER | FALSE    | 半期（1/2）    |
| SCORE       | NUMBER | FALSE    | 評価点数       |

### サンプルデータ

**HR_DEPARTMENT**：

| DEPT_ID | DEPT_NAME_KR | DEPT_NAME_EN       | LOCATION       |
|---------|--------------|-------------------|----------------|
| D0001   | 法務チーム   | Law Dep           | グレップタワー4階 |
| D0002   | 人事チーム   | Human Resources   | グレップタワー4階 |
| D0003   | 総務チーム   | General Affairs   | グレップタワー4階 |

**HR_EMPLOYEES**：

| EMP_NO  | EMP_NAME   | DEPT_ID | POSITION | EMAIL                      | COMP_TEL      | HIRE_DATE  | SAL      |
|---------|------------|---------|----------|----------------------------|---------------|------------|----------|
| 2017002 | チョン・ホシク | D0001   | チーム長 | hosick_jung@grepp.com      | 031-8000-1101 | 2017-03-01 | 65000000 |
| 2018001 | キム・ミンソク | D0001   | チーム員 | minseock_kim@grepp.com     | 031-8000-1102 | 2018-03-01 | 60000000 |
| 2019001 | キム・ソミ     | D0002   | チーム長 | somi_kim@grepp.com         | 031-8000-1106 | 2019-03-01 | 60000000 |
| 2020002 | キム・ヨンジュ | D0002   | チーム員 | yeonjoo_kim@grepp.com      | 031-8000-1107 | 2020-03-01 | 53000000 |
| 2020005 | ヤン・ソンテ   | D0003   | チーム員 | sungtae_yang@grepp.com     | 031-8000-1112 | 2020-03-01 | 53000000 |

**HR_GRADE**：

| EMP_NO  | YEAR | HALF_YEAR | SCORE |
|---------|------|-----------|-------|
| 2017002 | 2022 | 1         | 92    |
| 2018001 | 2022 | 1         | 89    |
| 2019001 | 2022 | 1         | 94    |
| 2020002 | 2022 | 1         | 90    |
| 2020005 | 2022 | 1         | 92    |
| 2017002 | 2022 | 2         | 84    |
| 2018001 | 2022 | 2         | 89    |
| 2019001 | 2022 | 2         | 81    |
| 2020002 | 2022 | 2         | 91    |
| 2020005 | 2022 | 2         | 81    |

**年間合計点の計算**：
- 2017002: 92 + 84 = 176
- 2018001: 89 + 89 = 178
- 2019001: 94 + 81 = 175
- 2020002: 90 + 91 = **181（最高）**
- 2020005: 92 + 81 = 173

## 🎯 期待される出力

| SCORE | EMP_NO  | EMP_NAME       | POSITION | EMAIL                  |
|-------|---------|----------------|----------|------------------------|
| 181   | 2020002 | キム・ヨンジュ | チーム員 | yeonjoo_kim@grepp.com  |

## 💡 解答

### 最適化されたSQL

```sql
SELECT
    SUM(g.SCORE) AS SCORE,
    e.EMP_NO,
    e.EMP_NAME,
    e.POSITION,
    e.EMAIL
FROM HR_GRADE g
INNER JOIN HR_EMPLOYEES e ON g.EMP_NO = e.EMP_NO
WHERE g.YEAR = 2022
GROUP BY e.EMP_NO, e.EMP_NAME, e.POSITION, e.EMAIL
ORDER BY SCORE DESC
LIMIT 1;
```

## 📝 解説

### 解法のポイント

1. **テーブル結合（INNER JOIN）**
   ```sql
   FROM HR_GRADE g
   INNER JOIN HR_EMPLOYEES e ON g.EMP_NO = e.EMP_NO
   ```
   - 評価情報（HR_GRADE）と社員情報（HR_EMPLOYEES）を結合
   - EMP_NOで紐付け
   - HR_DEPARTMENTは不要（出力に部署情報なし）

2. **年度フィルタリング（WHERE）**
   ```sql
   WHERE g.YEAR = 2022
   ```
   - 2022年度の評価のみ抽出
   - GROUP BY前にフィルタリングして処理対象を削減

3. **社員別の集計（GROUP BY + SUM）**
   ```sql
   GROUP BY e.EMP_NO, e.EMP_NAME, e.POSITION, e.EMAIL
   ```
   - 社員ごとに上半期と下半期の点数を合計
   - SELECT句の非集計カラムをすべて含める（MySQL）

4. **最高点の取得（ORDER BY + LIMIT）**
   ```sql
   ORDER BY SCORE DESC
   LIMIT 1
   ```
   - 合計点で降順ソート
   - 最上位1件のみ取得

### GROUP BYの注意点

**MySQLのGROUP BYルール**：
- SELECT句の非集計カラムは、すべてGROUP BYに含める必要がある
- または、集計関数内に含める

**正しい**：
```sql
SELECT
    SUM(g.SCORE) AS SCORE,
    e.EMP_NO,
    e.EMP_NAME,
    e.POSITION,
    e.EMAIL
FROM ...
GROUP BY e.EMP_NO, e.EMP_NAME, e.POSITION, e.EMAIL
```

**間違い**：
```sql
GROUP BY e.EMP_NO  -- 他の非集計カラムが含まれていない
```

**理由**：
- EMP_NOが同じでも、他のカラムが異なる可能性がある
- すべての非集計カラムでグループ化する必要がある
- 実際には、EMP_NOがPKなら他のカラムは一意に決まるが、SQLの文法上必要

### パフォーマンスチューニング

#### インデックス戦略

**推奨インデックス**：
```sql
-- HR_GRADEのYEARとEMP_NOに複合インデックス
CREATE INDEX idx_grade_year_emp ON HR_GRADE(YEAR, EMP_NO);

-- HR_EMPLOYEESのEMP_NOにインデックス（PKの場合は不要）
CREATE INDEX idx_employees_emp ON HR_EMPLOYEES(EMP_NO);
```

**効果**：
- WHERE句のYEAR = 2022で高速フィルタリング
- JOIN条件のEMP_NOで効率的な結合
- GROUP BYの集計を最適化

#### 実行計画の確認

```sql
EXPLAIN SELECT
    SUM(g.SCORE) AS SCORE,
    e.EMP_NO,
    e.EMP_NAME,
    e.POSITION,
    e.EMAIL
FROM HR_GRADE g
INNER JOIN HR_EMPLOYEES e ON g.EMP_NO = e.EMP_NO
WHERE g.YEAR = 2022
GROUP BY e.EMP_NO, e.EMP_NAME, e.POSITION, e.EMAIL
ORDER BY SCORE DESC
LIMIT 1;
```

**チェックポイント**：
- `type`: `ref`（インデックス使用）
- `key`: インデックスが使用されることを確認
- `Extra`: `Using temporary; Using filesort` は許容範囲（GROUP BYとORDER BY）

### 代替アプローチ

#### オプション1：サブクエリで最大値を取得

```sql
SELECT
    SUM(g.SCORE) AS SCORE,
    e.EMP_NO,
    e.EMP_NAME,
    e.POSITION,
    e.EMAIL
FROM HR_GRADE g
INNER JOIN HR_EMPLOYEES e ON g.EMP_NO = e.EMP_NO
WHERE g.YEAR = 2022
GROUP BY e.EMP_NO, e.EMP_NAME, e.POSITION, e.EMAIL
HAVING SUM(g.SCORE) = (
    SELECT MAX(total_score)
    FROM (
        SELECT SUM(SCORE) AS total_score
        FROM HR_GRADE
        WHERE YEAR = 2022
        GROUP BY EMP_NO
    ) AS scores
);
```

**評価**：
- HAVINGで最大値と比較
- サブクエリで2回スキャン（内側：全社員の合計、外側：最大値）
- ORDER BY + LIMITより複雑で非効率
- 推奨しない

#### オプション2：ウィンドウ関数（RANK）

```sql
WITH ranked_employees AS (
    SELECT
        SUM(g.SCORE) AS SCORE,
        e.EMP_NO,
        e.EMP_NAME,
        e.POSITION,
        e.EMAIL,
        RANK() OVER (ORDER BY SUM(g.SCORE) DESC) AS rank_num
    FROM HR_GRADE g
    INNER JOIN HR_EMPLOYEES e ON g.EMP_NO = e.EMP_NO
    WHERE g.YEAR = 2022
    GROUP BY e.EMP_NO, e.EMP_NAME, e.POSITION, e.EMAIL
)
SELECT SCORE, EMP_NO, EMP_NAME, POSITION, EMAIL
FROM ranked_employees
WHERE rank_num = 1;
```

**評価**：
- 同点の場合、すべての最高点社員を取得できる
- ウィンドウ関数の理解が必要
- やや複雑だがエレガント
- 同点を考慮する場合に推奨

#### オプション3：相関サブクエリ

```sql
SELECT
    (SELECT SUM(SCORE) FROM HR_GRADE WHERE EMP_NO = e.EMP_NO AND YEAR = 2022) AS SCORE,
    e.EMP_NO,
    e.EMP_NAME,
    e.POSITION,
    e.EMAIL
FROM HR_EMPLOYEES e
WHERE (SELECT SUM(SCORE) FROM HR_GRADE WHERE EMP_NO = e.EMP_NO AND YEAR = 2022) = (
    SELECT MAX(total_score)
    FROM (
        SELECT SUM(SCORE) AS total_score
        FROM HR_GRADE
        WHERE YEAR = 2022
        GROUP BY EMP_NO
    ) AS scores
);
```

**評価**：
- 相関サブクエリで非効率
- 各行ごとにサブクエリ実行
- 推奨しない

### WHERE句 vs HAVING句

**WHERE句**：
- GROUP BY前にフィルタリング
- 集計関数を使えない
- 例：`WHERE g.YEAR = 2022`

**HAVING句**：
- GROUP BY後にフィルタリング
- 集計関数を使える
- 例：`HAVING SUM(g.SCORE) > 150`

**今回のクエリ**：
- `WHERE g.YEAR = 2022`：集計前にフィルタ（効率的）
- HAVING句は使用せず、ORDER BY + LIMITで最大値を取得

## 🔑 キーワード

- `INNER JOIN`：2テーブル結合
- `GROUP BY`：社員別集計
- `SUM()`：点数の合計
- `ORDER BY DESC`：降順ソート
- `LIMIT 1`：最上位1件取得
- **WHERE vs HAVING**：集計前後のフィルタリング
- **GROUP BYの非集計カラム**：すべて含める必要
- **最大値取得パターン**：ORDER BY + LIMIT vs サブクエリ

## 🎓 学習ポイント

1. 複数テーブルのINNER JOINで必要なデータを結合
2. GROUP BYとSUM()で社員別の合計を計算
3. ORDER BY + LIMITで最大値を効率的に取得
4. WHERE句で集計前にフィルタリングして効率化
5. GROUP BYには非集計カラムをすべて含める
6. サブクエリよりORDER BY + LIMITが効率的
7. ウィンドウ関数は同点を考慮する場合に有用

## 💡 応用例

### 上位3名の社員を取得

```sql
SELECT
    SUM(g.SCORE) AS SCORE,
    e.EMP_NO,
    e.EMP_NAME,
    e.POSITION,
    e.EMAIL
FROM HR_GRADE g
INNER JOIN HR_EMPLOYEES e ON g.EMP_NO = e.EMP_NO
WHERE g.YEAR = 2022
GROUP BY e.EMP_NO, e.EMP_NAME, e.POSITION, e.EMAIL
ORDER BY SCORE DESC
LIMIT 3;
```

### 部署別の最高点社員

```sql
SELECT
    d.DEPT_NAME_KR,
    SUM(g.SCORE) AS SCORE,
    e.EMP_NO,
    e.EMP_NAME,
    e.POSITION
FROM HR_GRADE g
INNER JOIN HR_EMPLOYEES e ON g.EMP_NO = e.EMP_NO
INNER JOIN HR_DEPARTMENT d ON e.DEPT_ID = d.DEPT_ID
WHERE g.YEAR = 2022
GROUP BY d.DEPT_NAME_KR, e.EMP_NO, e.EMP_NAME, e.POSITION
ORDER BY d.DEPT_NAME_KR, SCORE DESC;
```

### 同点の最高点社員をすべて取得

```sql
WITH employee_scores AS (
    SELECT
        SUM(g.SCORE) AS SCORE,
        e.EMP_NO,
        e.EMP_NAME,
        e.POSITION,
        e.EMAIL
    FROM HR_GRADE g
    INNER JOIN HR_EMPLOYEES e ON g.EMP_NO = e.EMP_NO
    WHERE g.YEAR = 2022
    GROUP BY e.EMP_NO, e.EMP_NAME, e.POSITION, e.EMAIL
)
SELECT *
FROM employee_scores
WHERE SCORE = (SELECT MAX(SCORE) FROM employee_scores);
```

### 半期別の評価詳細

```sql
SELECT
    e.EMP_NO,
    e.EMP_NAME,
    MAX(CASE WHEN g.HALF_YEAR = 1 THEN g.SCORE END) AS FIRST_HALF,
    MAX(CASE WHEN g.HALF_YEAR = 2 THEN g.SCORE END) AS SECOND_HALF,
    SUM(g.SCORE) AS TOTAL_SCORE
FROM HR_GRADE g
INNER JOIN HR_EMPLOYEES e ON g.EMP_NO = e.EMP_NO
WHERE g.YEAR = 2022
GROUP BY e.EMP_NO, e.EMP_NAME
ORDER BY TOTAL_SCORE DESC;
```

### 評価点数の統計情報

```sql
SELECT
    e.DEPT_ID,
    d.DEPT_NAME_KR,
    COUNT(DISTINCT e.EMP_NO) AS EMPLOYEE_COUNT,
    AVG(total_scores.SCORE) AS AVG_SCORE,
    MAX(total_scores.SCORE) AS MAX_SCORE,
    MIN(total_scores.SCORE) AS MIN_SCORE
FROM HR_EMPLOYEES e
INNER JOIN HR_DEPARTMENT d ON e.DEPT_ID = d.DEPT_ID
INNER JOIN (
    SELECT EMP_NO, SUM(SCORE) AS SCORE
    FROM HR_GRADE
    WHERE YEAR = 2022
    GROUP BY EMP_NO
) AS total_scores ON e.EMP_NO = total_scores.EMP_NO
GROUP BY e.DEPT_ID, d.DEPT_NAME_KR
ORDER BY AVG_SCORE DESC;
```

### 年度別の最高点推移

```sql
SELECT
    g.YEAR,
    MAX(total_score) AS MAX_SCORE,
    (
        SELECT e.EMP_NAME
        FROM HR_EMPLOYEES e
        INNER JOIN (
            SELECT EMP_NO, SUM(SCORE) AS score
            FROM HR_GRADE
            WHERE YEAR = g.YEAR
            GROUP BY EMP_NO
        ) AS year_scores ON e.EMP_NO = year_scores.EMP_NO
        ORDER BY year_scores.score DESC
        LIMIT 1
    ) AS TOP_EMPLOYEE
FROM HR_GRADE g
INNER JOIN (
    SELECT YEAR, EMP_NO, SUM(SCORE) AS total_score
    FROM HR_GRADE
    GROUP BY YEAR, EMP_NO
) AS scores ON g.YEAR = scores.YEAR
GROUP BY g.YEAR
ORDER BY g.YEAR;
```

---

**作成日**: 2025-10-08
**難易度**: ⭐⭐ 中級
**カテゴリ**: INNER JOIN, GROUP BY, SUM, ORDER BY + LIMIT, 複数テーブル結合
