# 特定形質大腸菌カウント

## 📖 問題文（日本語訳）

大腸菌は一定周期で分化し、分化を始めた個体を親個体、分化してできた個体を子個体と呼びます。

以下は実験室で培養した大腸菌の情報を含む ECOLI_DATA テーブルです。

2 番形質を保有しておらず、1 番または 3 番形質を保有している大腸菌個体の数（COUNT）を出力する SQL 文を作成してください。

1 番と 3 番形質を両方保有している場合も、1 番または 3 番形質を保有している場合に含まれます。

## 📊 テーブル構造

### ECOLI_DATA テーブル

ID、PARENT_ID、SIZE_OF_COLONY、DIFFERENTIATION_DATE、GENOTYPE は、それぞれ大腸菌個体の ID、親個体の ID、個体のサイズ、分化した日付、個体の形質を表します。

最初の大腸菌個体の PARENT_ID は NULL 値です。

| Column name          | Type    | Nullable |
| -------------------- | ------- | -------- |
| ID                   | INTEGER | FALSE    |
| PARENT_ID            | INTEGER | TRUE     |
| SIZE_OF_COLONY       | INTEGER | FALSE    |
| DIFFERENTIATION_DATE | DATE    | FALSE    |
| GENOTYPE             | INTEGER | FALSE    |

**サンプルデータ:**

| ID  | PARENT_ID | SIZE_OF_COLONY | DIFFERENTIATION_DATE | GENOTYPE |
| --- | --------- | -------------- | -------------------- | -------- |
| 1   | NULL      | 10             | 2019-01-01           | 8        |
| 2   | NULL      | 2              | 2019-01-01           | 15       |
| 3   | 2         | 100            | 2020-01-01           | 1        |
| 4   | 2         | 16             | 2020-01-01           | 13       |

## 🎯 期待される出力

| COUNT |
| ----- |
| 2     |

## 💡 解答

```sql
SELECT
    COUNT(*) AS COUNT
FROM ECOLI_DATA
WHERE (GENOTYPE & 2) = 0
    AND ((GENOTYPE & 1) > 0 OR (GENOTYPE & 4) > 0);
```

## 📝 解説

### アプローチ

1. GENOTYPE をビット演算で形質保有状況を判定
2. WHERE 句で 2 番形質を持たない条件を指定
3. WHERE 句で 1 番または 3 番形質を持つ条件を追加
4. COUNT(\*) で条件を満たす個体数をカウント

### 形質とビット演算の理解

GENOTYPE は整数値で、2 進数で各形質の保有状況を表します。

**各大腸菌の形質（2 進数表現）：**

| ID  | GENOTYPE | 2 進数  | 保有形質      |
| --- | -------- | ------- | ------------- |
| 1   | 8        | 1000₍₂₎ | 4             |
| 2   | 15       | 1111₍₂₎ | 1, 2, 3, 4    |
| 3   | 1        | 0001₍₂₎ | 1             |
| 4   | 13       | 1101₍₂₎ | 1, 3, 4       |

**形質とビット位置の対応：**

- 1 番形質：1 ビット目（2⁰ = 1）
- 2 番形質：2 ビット目（2¹ = 2）
- 3 番形質：3 ビット目（2² = 4）
- 4 番形質：4 ビット目（2³ = 8）

### 条件判定の流れ

**2 番形質を持たない個体：**

- ID 1: (8 & 2) = 0 ✓
- ID 2: (15 & 2) = 2 ✗（除外）
- ID 3: (1 & 2) = 0 ✓
- ID 4: (13 & 2) = 0 ✓

**1 番または 3 番形質を持つ個体（上記のうち）：**

- ID 1: (8 & 1) = 0 かつ (8 & 4) = 0 ✗（除外）
- ID 3: (1 & 1) = 1 ✓
- ID 4: (13 & 1) = 1 ✓

**結果：** ID 3 と ID 4 の 2 個体

### 学習ポイント

- **ビット演算子（&）**: 2 つの値のビット単位の論理積を計算
- **形質判定**: `(GENOTYPE & ビット値) > 0` で特定形質の保有を判定
- **複雑な論理条件**: NOT AND (OR) の組み合わせ
- **COUNT 関数**: 条件を満たすレコード数をカウント

### ビット演算の基本

**AND 演算子（&）の動作：**

```
  1101₍₂₎  (13)
& 0001₍₂₎  (1)
----------
  0001₍₂₎  (1)  → 1番形質あり

  1101₍₂₎  (13)
& 0010₍₂₎  (2)
----------
  0000₍₂₎  (0)  → 2番形質なし

  1101₍₂₎  (13)
& 0100₍₂₎  (4)
----------
  0100₍₂₎  (4)  → 3番形質あり
```

### 各形質の判定方法

```sql
-- 1番形質を持つ
WHERE (GENOTYPE & 1) > 0

-- 2番形質を持つ
WHERE (GENOTYPE & 2) > 0

-- 3番形質を持つ
WHERE (GENOTYPE & 4) > 0

-- 4番形質を持つ
WHERE (GENOTYPE & 8) > 0

-- 2番形質を持たない
WHERE (GENOTYPE & 2) = 0
```

### 複雑な条件の組み合わせ

```sql
-- 条件: NOT 2 AND (1 OR 3)
WHERE (GENOTYPE & 2) = 0                    -- 2番形質なし
    AND ((GENOTYPE & 1) > 0                 -- 1番形質あり
         OR (GENOTYPE & 4) > 0)             -- または3番形質あり
```

### 代替的な書き方

```sql
-- 同じ意味（括弧の位置が違う）
WHERE (GENOTYPE & 2) = 0
    AND ((GENOTYPE & 1) + (GENOTYPE & 4)) > 0

-- 同じ意味（ビットマスクを使用）
WHERE (GENOTYPE & 2) = 0
    AND (GENOTYPE & 5) > 0  -- 5 = 1 + 4 (1番と3番)
```

## 🔑 キーワード

- ビット演算子（&）
- GENOTYPE（遺伝子型）
- WHERE 句（複雑な条件）
- COUNT 関数
- 論理演算（AND、OR）
