# よくあるパターンと解法

## 📋 目次
1. [ランキング問題](#ランキング問題)
2. [累積計算](#累積計算)
3. [重複削除](#重複削除)
4. [N番目の値を取得](#n番目の値を取得)
5. [グループごとの最大・最小](#グループごとの最大最小)
6. [日付計算](#日付計算)
7. [文字列操作](#文字列操作)

---

## ランキング問題

### パターン1: 単純なランキング
```sql
-- 給与の高い順にランキング
SELECT first_name, salary,
       RANK() OVER (ORDER BY salary DESC) as 順位
FROM employees;
```

### パターン2: グループごとのランキング
```sql
-- 部署ごとに給与の高い順にランキング
SELECT department_id, first_name, salary,
       RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as 部署内順位
FROM employees;
```

### パターン3: トップNを取得
```sql
-- 各部署の給与トップ3
WITH ranked AS (
    SELECT department_id, first_name, salary,
           RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as rn
    FROM employees
)
SELECT * FROM ranked WHERE rn <= 3;
```

---

## 累積計算

### パターン1: 累積合計
```sql
-- 日付順の累積売上
SELECT sale_date, revenue,
       SUM(revenue) OVER (ORDER BY sale_date) as 累積売上
FROM sales;
```

### パターン2: 移動平均
```sql
-- 3日間の移動平均
SELECT sale_date, revenue,
       AVG(revenue) OVER (
           ORDER BY sale_date
           ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
       ) as 移動平均
FROM sales;
```

### パターン3: 前期比較
```sql
-- 前月比の計算
SELECT sale_date, revenue,
       LAG(revenue) OVER (ORDER BY sale_date) as 前月売上,
       revenue - LAG(revenue) OVER (ORDER BY sale_date) as 増減額,
       ROUND((revenue - LAG(revenue) OVER (ORDER BY sale_date)) /
             LAG(revenue) OVER (ORDER BY sale_date) * 100, 2) as 増減率
FROM sales;
```

---

## 重複削除

### パターン1: DISTINCT
```sql
-- 重複する部署IDを除外
SELECT DISTINCT department_id
FROM employees;
```

### パターン2: GROUP BY
```sql
-- 顧客ごとの最初の注文
SELECT customer_id, MIN(order_date) as 初回注文日
FROM orders
GROUP BY customer_id;
```

### パターン3: ROW_NUMBER で重複削除
```sql
-- 各顧客の最新の注文のみ取得
WITH numbered AS (
    SELECT *,
           ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY order_date DESC) as rn
    FROM orders
)
SELECT * FROM numbered WHERE rn = 1;
```

---

## N番目の値を取得

### パターン1: LIMIT と OFFSET
```sql
-- 2番目に給与が高い従業員
SELECT first_name, salary
FROM employees
ORDER BY salary DESC
LIMIT 1 OFFSET 1;
```

### パターン2: サブクエリ
```sql
-- N番目に高い給与を取得（N=2）
SELECT MAX(salary)
FROM employees
WHERE salary < (SELECT MAX(salary) FROM employees);
```

### パターン3: ウィンドウ関数
```sql
-- 各部署の2番目に給与が高い従業員
WITH ranked AS (
    SELECT department_id, first_name, salary,
           ROW_NUMBER() OVER (PARTITION BY department_id ORDER BY salary DESC) as rn
    FROM employees
)
SELECT * FROM ranked WHERE rn = 2;
```

---

## グループごとの最大・最小

### パターン1: 相関サブクエリ
```sql
-- 各部署で最高給与の従業員
SELECT first_name, department_id, salary
FROM employees e1
WHERE salary = (
    SELECT MAX(salary)
    FROM employees e2
    WHERE e1.department_id = e2.department_id
);
```

### パターン2: JOIN + 集計
```sql
-- 各部署の最高給与者
SELECT e.first_name, e.department_id, e.salary
FROM employees e
JOIN (
    SELECT department_id, MAX(salary) as max_salary
    FROM employees
    GROUP BY department_id
) max_sal ON e.department_id = max_sal.department_id
         AND e.salary = max_sal.max_salary;
```

### パターン3: ウィンドウ関数
```sql
-- 各部署の最高給与者
WITH ranked AS (
    SELECT first_name, department_id, salary,
           RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as rn
    FROM employees
)
SELECT first_name, department_id, salary
FROM ranked WHERE rn = 1;
```

---

## 日付計算

### パターン1: 期間のフィルタリング
```sql
-- 過去30日間の注文
SELECT *
FROM orders
WHERE order_date >= CURRENT_DATE - INTERVAL '30 days';

-- 特定の月の注文
SELECT *
FROM orders
WHERE DATE_TRUNC('month', order_date) = '2025-09-01';
```

### パターン2: 年齢計算
```sql
-- 従業員の勤続年数
SELECT first_name, hire_date,
       EXTRACT(YEAR FROM AGE(CURRENT_DATE, hire_date)) as 勤続年数
FROM employees;
```

### パターン3: 日付のグループ化
```sql
-- 月別売上集計
SELECT DATE_TRUNC('month', sale_date) as 月,
       SUM(revenue) as 月間売上
FROM sales
GROUP BY DATE_TRUNC('month', sale_date)
ORDER BY 月;
```

---

## 文字列操作

### パターン1: 連結
```sql
-- フルネームの作成
SELECT CONCAT(last_name, ' ', first_name) as フルネーム
FROM employees;

-- PostgreSQL / MySQL の場合
SELECT last_name || ' ' || first_name as フルネーム
FROM employees;
```

### パターン2: 部分文字列
```sql
-- メールアドレスからドメインを抽出
SELECT email,
       SUBSTRING(email FROM POSITION('@' IN email) + 1) as ドメイン
FROM employees;
```

### パターン3: パターンマッチング
```sql
-- 特定のパターンに一致する顧客
SELECT customer_name
FROM customers
WHERE customer_name LIKE '株式会社%';

-- 正規表現（PostgreSQL）
SELECT customer_name
FROM customers
WHERE customer_name ~ '^株式会社.*';
```

### パターン4: 大文字小文字変換
```sql
-- 大文字に変換
SELECT UPPER(first_name) FROM employees;

-- 小文字に変換
SELECT LOWER(first_name) FROM employees;
```

---

## 🎯 パフォーマンスのヒント

### インデックスを活用
```sql
-- WHERE句でよく使うカラムにインデックス
CREATE INDEX idx_employee_dept ON employees(department_id);
CREATE INDEX idx_order_date ON orders(order_date);
```

### EXISTS vs IN
```sql
-- 大きなテーブルではEXISTSの方が速い
SELECT *
FROM customers c
WHERE EXISTS (
    SELECT 1 FROM orders o WHERE o.customer_id = c.customer_id
);
```

### UNION vs UNION ALL
```sql
-- 重複削除が不要な場合はUNION ALLを使う（速い）
SELECT first_name FROM employees
UNION ALL
SELECT customer_name FROM customers;
```

---

## 💡 デバッグのコツ

1. **段階的に構築**: 複雑なクエリは小さく分けて確認
2. **EXPLAINを使う**: クエリの実行計画を確認
3. **サンプルデータで検証**: 小さなデータセットで動作確認
4. **結果の行数を確認**: 期待した行数が返っているか
5. **NULLに注意**: NULL値の扱いがよくエラーの原因

---

**最終更新**: 2025-10-06
