# SQL 学習記録

## 📊 学習統計

| 項目         | 数値  |
| ------------ | ----- |
| 総学習日数   | 2 日  |
| 作成問題数   | 20 問 |
| 基本レベル   | 17 問 |
| 中級レベル   | 3 問  |
| 上級レベル   | 0 問  |

## 🎯 現在の学習目標

- [ ] SELECT 文の基礎をマスターする
- [ ] JOIN 操作を理解する
- [ ] 集計関数を使いこなす

## 📅 日別学習記録

### 2025-10-08（火）

**学習時間**: 3.5 時間

**作成した問題**:

**基本レベル（6 問）:**

1. 3月生まれの女性会員検索（WHERE複数条件、MONTH関数、IS NOT NULL、インデックス最適化）
2. 最大魚長検索（MAX関数、CONCAT関数、降順インデックス最適化）
3. レンタル期間分類検索（CASE式、DATEDIFF関数、日付範囲検索）
4. 価格帯別商品数集計（FLOOR関数、GROUP BY計算式、DIV演算子）
5. ROOTアイテム検索（INNER JOIN、IS NULL、階層データ構造）
6. 中古取引掲示板特定日検索（簡易CASE式、日付等価検索、ORDER BY DESC）

**中級レベル（1 問）:**

1. 最高評価社員検索（複数テーブルJOIN、GROUP BY + SUM、ORDER BY + LIMIT）

**学んだ内容**:

- `MONTH()` 関数を使った日付抽出
- `IS NOT NULL` による NULL値の除外
- WHERE句の条件順序によるパフォーマンス最適化
- 複合インデックス設計の基礎
- 生成列（Generated Column）を使った関数インデックス
- `EXPLAIN` 文による実行計画の確認方法
- カバリングインデックスの概念
- `MAX()` 集計関数とNULL値の自動除外
- `CONCAT()` 関数による文字列結合
- 降順インデックスによる集計関数最適化
- 集計関数のO(1)検索の実現方法
- `CASE` 式による条件分岐とカラム追加
- `DATEDIFF()` 関数による日付差分計算
- 実日数の計算方法（DATEDIFF + 1）
- 日付範囲検索でのインデックス活用
- YEAR/MONTH関数より範囲検索が効率的
- `FLOOR()` 関数による小数点切り捨て
- `DIV` 演算子による整数除算
- GROUP BYでの計算式の使用
- GROUP BYでエイリアスを使用できる（MySQL）
- 価格帯グループ化の実務パターン
- 生成列（Generated Column）による計算式の事前保存とインデックス化
- INNER JOINによる2テーブルの結合
- `IS NULL` によるNULL値の正確な検索
- `= NULL` は使えない（常にFALSE）
- 階層データ（ツリー構造）の基本概念
- ROOTノード（親を持たない最上位ノード）の理解
- テーブルエイリアスによる可読性向上
- NULLもインデックスに含まれる（MySQL）
- 簡易CASE式（`CASE column WHEN value`）と検索CASE式（`CASE WHEN condition`）の違い
- ステータスコード変換パターン
- 日付の等価検索（関数を使わずインデックス活用）
- ORDER BY DESC（降順ソート）
- 降順インデックス（`CREATE INDEX ... DESC`）の効果
- 複数テーブルのINNER JOIN（3テーブル結合）
- GROUP BYとSUM()の組み合わせで集計
- GROUP BYでの非集計カラムの扱い（すべて含める必要）
- ORDER BY + LIMITで最大値を効率的に取得
- WHERE句とHAVING句の使い分け（集計前後のフィルタ）
- 最大値取得の3つの方法（ORDER BY + LIMIT、サブクエリ、ウィンドウ関数）

**パフォーマンスチューニングのポイント**:

- WHERE句の条件順序：カーディナリティの低い条件を先に配置
- 関数を使用した条件はインデックスが効きにくい
- 生成列を使うことで関数計算のオーバーヘッドを削減可能
- 降順インデックスでMAX()を劇的に高速化（O(n) → O(1)）
- 集計関数はNULL値を自動除外するため明示的WHERE不要
- ORDER BY + LIMIT より MAX() の方が効率的
- 日付範囲検索（>= AND <）でインデックスを活用
- YEAR/MONTH関数より `date >= '2022-09-01' AND date < '2022-10-01'` が高速
- 複合インデックスでWHERE句とORDER BY両方を最適化
- GROUP BY計算式はインデックスが直接効かないが、元カラムのインデックスで効率化
- 生成列を使うと計算式に直接インデックスを作成可能
- GROUP BYとORDER BYが同じ列/式なら効率的
- PARENT_ITEM_IDにインデックスでIS NULL検索も高速化
- JOIN条件のカラムにインデックスで結合を最適化
- 複合インデックスでWHEREとJOINの両方をカバー
- 日付検索に関数を使うとインデックスが効かない（`DATE() =` は非効率）
- 等価検索（`date = 'YYYY-MM-DD'`）が最も効率的
- 複合インデックス（WHERE + ORDER BY）でソート操作を削減
- 降順インデックスとORDER BY DESCの組み合わせで最適化
- WHERE句で集計前にフィルタリングして処理対象を削減
- GROUP BYの前にWHERE句でフィルタが効率的
- ORDER BY + LIMITはサブクエリより効率的（1回スキャン vs 2回スキャン）
- 複合インデックス（YEAR, EMP_NO）でJOINとGROUP BYを最適化

**今日の達成**:

- 基本レベル6問、中級レベル1問を完成
- パフォーマンスチューニングの深い理解
- 複数テーブルJOINと集計の実践

**次回の予定**:

- ウィンドウ関数（RANK、ROW_NUMBER）の学習
- 再帰CTE（WITH RECURSIVE）の実践
- サブクエリの高度な使い方

---

### 2025-10-07（月）

**学習時間**: 0.5 時間

**作成した問題**:

**基本レベル（11 問）:**

1. 中古取引掲示板とコメント結合（INNER JOIN）
2. 果物ベースアイスクリーム照会（INNER JOIN、WHERE、ORDER BY）
3. 動物名と保護開始日照会（SELECT、ORDER BY DESC）
4. 病気の動物照会（WHERE、等価条件）
5. 若い動物照会（WHERE、否定条件）
6. 特定診療科医師照会（IN 演算子、DATE_FORMAT）
7. 小児女性患者照会（AND 条件、IFNULL）
8. 特定年カテゴリ書籍照会（YEAR 関数、DATE_FORMAT）
9. SUV 平均レンタル料金（AVG、ROUND 関数）
10. 江原道工場照会（LIKE 演算子、ワイルドカード）
11. 最初の動物名照会（ORDER BY、LIMIT）

**中級レベル（2 問）:**

1. 再購入商品照会（GROUP BY、HAVING、COUNT）
2. 特定形質大腸菌カウント（ビット演算、複雑な条件）

**学んだ内容**:

- INNER JOIN の基本と複数テーブル結合
- WHERE 句（等価、否定、複数条件、LIKE、IN）
- ORDER BY（昇順・降順、複数カラム）
- 集計関数（AVG、COUNT、ROUND）
- 日付関数（DATE_FORMAT、YEAR、BETWEEN）
- NULL 処理（IFNULL）
- LIMIT 句と Top-N クエリ
- GROUP BY と HAVING の組み合わせ
- ビット演算子（&）
- ワイルドカード（%）とパターンマッチング

**次回の予定**:

- サブクエリの練習
- ウィンドウ関数の学習

---

### 2025-10-06（日）

**学習時間**: 0 時間

**解いた問題**:

- なし

**学んだ内容**:

- プロジェクト構造を作成

**次回の予定**:

- 基本的な SELECT 問題から開始

---

## 📈 週次レビュー

### 2025 年 10 月第 1 週

**達成したこと**:

- プロジェクトセットアップ完了

**課題**:

- なし

**来週の目標**:

- 基本レベルの問題を 5 問解く

---

## 🏆 習得スキル一覧

### SELECT 文

- [x] 基本的な SELECT
- [x] WHERE 条件（複数条件、IS NOT NULL、日付範囲検索）
- [x] ORDER BY 並び替え（昇順・降順、降順インデックス最適化）
- [x] LIMIT 制限
- [x] CASE 式（簡易CASE、検索CASE、ステータス変換）
- [ ] DISTINCT 重複削除

### 集計関数

- [x] COUNT
- [x] SUM（GROUP BYとの組み合わせ、複数行の合計）
- [x] AVG
- [x] MAX/MIN（NULLの自動除外、降順インデックス最適化）
- [x] GROUP BY（非集計カラムの扱い、複数カラムでのグループ化）
- [x] HAVING（集計後のフィルタリング、WHERE句との使い分け）

### JOIN

- [x] INNER JOIN（2テーブル結合、3テーブル結合、IS NULL条件）
- [ ] LEFT JOIN
- [ ] RIGHT JOIN
- [ ] FULL OUTER JOIN
- [ ] CROSS JOIN
- [ ] SELF JOIN

### サブクエリ

- [ ] WHERE 句のサブクエリ
- [ ] FROM 句のサブクエリ
- [ ] SELECT 句のサブクエリ
- [ ] 相関サブクエリ

### ウィンドウ関数

- [ ] ROW_NUMBER
- [ ] RANK/DENSE_RANK
- [ ] LAG/LEAD
- [ ] SUM/AVG（ウィンドウ）

### データ操作

- [ ] INSERT
- [ ] UPDATE
- [ ] DELETE
- [ ] MERGE/UPSERT

### テーブル定義

- [ ] CREATE TABLE
- [ ] ALTER TABLE
- [ ] DROP TABLE
- [x] インデックス作成（複合インデックス、生成列インデックス）

---

## 💡 学習のヒント

### よくある間違い

- WHERE句で関数を使うとインデックスが効かなくなる可能性がある
- DATE_FORMAT()をWHERE句で使うとパフォーマンス低下の原因になる
- MAX()でNULL除外のためWHERE LENGTH IS NOT NULLを書く（冗長、不要）
- ORDER BY + LIMITをMAX()の代わりに使う（非効率）
- 日付抽出にYEAR/MONTH関数を使う（インデックスが効かない）
- DATEDIFFの結果を実日数と勘違いする（実日数 = DATEDIFF + 1）
- GROUP BYで計算式のエイリアスを使えないと思い込む（MySQLでは可能）
- 価格帯グループ化で複雑なCASE式を使う（FLOOR/DIVの方が簡潔）
- NULL検索に `= NULL` を使う（常にFALSE、`IS NULL`を使うべき）
- INNER JOINとLEFT JOINの使い分けを理解していない
- 日付検索にDATE()関数を使う（インデックスが効かない）
- 簡易CASEと検索CASEの使い分けができていない
- CASE式にELSE句を付けない（予期しない値への対応不足）
- GROUP BYに非集計カラムを含めない（エラーまたは予期しない結果）
- WHERE句とHAVING句を混同する
- 最大値取得にサブクエリを使う（ORDER BY + LIMITの方が効率的）

### 効率的な解法パターン

- **条件順序の最適化**: カーディナリティの低い条件 → NULL除外 → 関数使用条件
- **日付フォーマット**: SELECT句で変換してWHERE句のパフォーマンスを保つ
- **インデックス設計**: WHERE句の条件に合わせた複合インデックス作成
- **生成列活用**: 関数計算が頻繁な場合は生成列を使ってインデックス化
- **集計関数最適化**: MAX/MINには降順/昇順インデックスでO(1)検索
- **NULL処理の理解**: 集計関数は自動的にNULLを除外する
- **日付範囲検索**: `date >= '2022-09-01' AND date < '2022-10-01'` でインデックス活用
- **CASE式活用**: 条件分岐で動的にカラム値を生成
- **期間計算**: DATEDIFF()で日数差、実日数 = DATEDIFF + 1
- **価格帯グループ化**: `FLOOR(price / 10000) * 10000` または `(price DIV 10000) * 10000`
- **計算式のグループ化**: GROUP BYで計算式を使い、エイリアスも活用（MySQL）
- **生成列最適化**: 計算頻度が高い場合は生成列でインデックス化
- **NULL検索**: `IS NULL` を使用（`= NULL` は不可）
- **INNER JOIN活用**: 2テーブル結合で必要なデータを取得
- **階層データ検索**: PARENT_ITEM_ID IS NULLでROOTノードを抽出
- **簡易CASE式**: 等価比較のみの場合は `CASE column WHEN value` を使用
- **検索CASE式**: 複雑な条件の場合は `CASE WHEN condition` を使用
- **ステータス変換**: コード値を表示用テキストに変換する実務パターン
- **日付等価検索**: `date = 'YYYY-MM-DD'` でインデックス活用
- **降順インデックス**: ORDER BY DESCの場合は降順インデックスで最適化
- **GROUP BYルール**: SELECT句の非集計カラムはすべてGROUP BYに含める
- **WHERE vs HAVING**: WHEREは集計前、HAVINGは集計後のフィルタ
- **最大値取得**: ORDER BY + LIMITが最も効率的（1回スキャン）
- **複数テーブルJOIN**: 必要なテーブルのみ結合（不要なテーブルは避ける）

---

**最終更新**: 2025-10-08
